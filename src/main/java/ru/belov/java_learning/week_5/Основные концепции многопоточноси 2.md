### Современный API для многопоточности:

#### Atomic операции:
1. Что такое атомарные операции и какие классы предоставляет Java для их реализации?
	- Это неделимые операции, которые состоят из нескольких шагов, выполняются в одной транзакции и не могут быть прерваны другими потоками.
	- Классы:
		- ReentrantLock - более удобный и гибкий, чем synchronized блок кода
	     - AtomicInteger - для работы с целочисленными переменными
	     - AtomicBoolean - для работы с булевыми переменными
	     - AtomicDoubleAccumulator
	     - AtomicIntegerArray
	     - AtomicLongArray
	     - `AtomicReferenceArray<T>`
	     - всякие потокобезопасные коллекции
	- Операция increment (увеличения значения) на самом деле не атомарна и она состоит из 3 шагов:
		- загрузить значение переменной из памяти
		- изменить значение как `old + delta`, в этот момент old может измениться 
		- сохранить новое значение в память
	- так вот, все Atomic классы используют специальные инструкции процессора, которые гарантируют, что операция increment будет атомарной. Compare-And-Swap (CAS) — сравнивает текущее значение в памяти с ожидаемым, и если они совпадают, заменяет его на новое. Всё это выполняется атомарно на уровне процессора.
2. Как работает класс `AtomicInteger` и в чем его преимущество над стандартными целочисленными переменными?
	- Методы класса:
	- get()` → делает volatile read (внутри класс имеет `volatile int value`)
	- `set(int newValue)` → делает volatile write
	- `lazySet(int newValue)` → делает weaker volatile write (отложенный, но всё равно атомарный)
	- `incrementAndGet()` -  увеличить на 1, вернуть новое значение. 
	- `getAndIncrement()` -  увеличить на 1, вернуть старое значение. 
	- `decrementAndGet()` -  уменьшить на 1, вернуть новое значение. 
	- getAndDecrement()` -  уменьшить на 1, вернуть старое значение.
	- Методы `addAndGet(int delta)` и `getAndAdd(int delta)` реализованы через CAS (Compare-And-Swap) в цикле.
		- псевдокод для данных операций
			```java
		    public static void main(String[] args){
		        int prev, next;
		        do {
		            prev = get();            // volatile read
		            next = prev + delta;     // локальный расчёт
		        } while (!compareAndSet(prev, next));  // CAS
		        
		        return next;
		    }
		    ```
	- `boolean compareAndSet(int expect, int update)` — если текущее значение равно expect, то обновить его на update. Возвращает true/false.
	- `getAndUpdate(IntUnaryOperator updateFunction)` — применить функцию, вернуть старое значение. 
    - `updateAndGet(IntUnaryOperator updateFunction)` — применить функцию, вернуть новое значение.
    - `getAndUpdate()` и `updateAndGet()` - также работают с использованием механизма CAS
	    - Поток берёт текущее значение.
        - Применяет функцию.
        - Пытается обновить с помощью CAS.
        - Если другой поток успел изменить значение, CAS проваливается, и цикл повторяется.
        - В итоге операция атомарна, но может «покрутиться» в цикле несколько раз.
		```java
        public void addEnergy(){
	        energyReserve.updateAndGet(cur -> {
                    if (cur + energyToAdd > MAX_ENERGY_RESERVE) {
                        return MAX_ENERGY_RESERVE;
                    } else {
                        return cur + energyToAdd;
                    }
            });
        }
        ```
3. Как `compareAndSet()` используется для реализации атомарного обновления?
	- если текущее значение равно expect, то обновить его на update. Возвращает true/false.
    - то есть если кто-то до этого успел поменять значение, то оно не обновится
    - есть различные _weak-методы_, которые могут провалится, вернув false, даже если условие выполнено, например
	    - `weakCompareAndSet(int expect, int update)` - Может иногда не сработать даже если текущее значение равно ожидаемому.
	    - **Зачем?** - потенциально насколько я понимаю операция выполняется быстрее, что дает прирост производительности в алгоритмах, где допустимы такие провалы.
4. Приведите пример использования `AtomicLong` для безопасного параллельного инкремента.
	```java
	import java.util.concurrent.atomic.AtomicLong;
	
	public class AtomicLongExample {
	    private static AtomicLong counter = new AtomicLong(0);
	
	    public static void main(String[] args) throws InterruptedException {
	        int numThreads = 5;
	        int incrementsPerThread = 1000;
	
	        Thread[] threads = new Thread[numThreads];
	
	        for (int i = 0; i < numThreads; i++) {
	            threads[i] = new Thread(() -> {
	                for (int j = 0; j < incrementsPerThread; j++) {
	                    counter.incrementAndGet();  // или counter.getAndIncrement()
	                }
	            });
	            threads[i].start();
	        }
	
	        for (Thread t : threads) {
	            t.join();
	        }
	
	        System.out.println("Окончательное значение счетчика: " + counter.get());
	    }
	}
	```
#### Lock:

5. Чем `ReentrantLock` отличается от использования ключевого слова `synchronized`?
	- есть возможность попытки захвата без ожидания в случае не удачи, для этого есть метод `tryLock()` 
	- есть функция таймаута `boolean tryLock(timeout, TimeUnit)`
	- Нужно явно вызывать `unlock()` (обычно в finally)
6. Как `ReentrantLock` обрабатывает рекурсивные блокировки?
	- `ReentrantLock` как и `synchronized` имеет счетчик, при рекурсии он увеличивается, главное не забывать делать unlock()
7. Зачем использовать `tryLock()` вместо `lock()`?
	- выполнение альтернативного сценария, не блокируя поток, банально завершить выполнение метода например, чтобы не блокировать поток.
8. Как `ReadWriteLock` помогает в многопоточной среде?
	- По факту происходит разделение lock на два
	- читатель: `rwLock.readLock().lock()`
		- когда он блокировка произошла другие читатели также могут захватывать lock путем `rwLock.readLock().lock()`
		- однако писатель не сможет писать и при вызове `rwLock.writeLock().lock()` уйдет в ожидание
     - писатель: `rwLock.writeLock().lock()`
	     - блокирует доступ и читателям и писателям, так что все они уйдут в ожидание 
#### Callable, Task и Executors:

9. Что такое интерфейс `Callable` и как он отличается от `Runnable`?
	- Позволяет создавать задачи, которые возвращают результат и могут выбрасывать проверяемые исключения.
		```java
		public static void main(String[] args){
		    Callable<Integer> task = () -> {
			    Thread.sleep(1000);
			    return 52;
		    };
		}
		```
	- **Runnable**
		- Возвращаемое значение - `void`
		- Исключения - Может выбросить только `unchecked`
		- Метод - `run()`
	- **Callable**
		- Возвращаемое значение - `V` (объект любого типа)
		- Исключения - Может выбросить любые checked/unchecked(заложено в сигнатуру)
		- Метод - call()
10. Как создать задачу, возвращающую результат, с помощью `Callable`?
	- Можно как и в случае с **Runnable** имплементировать интерфейс
		```java
		import java.util.concurrent.Callable;
	
		public class MyCallable implements Callable<Integer> {
		    @Override
		    public Integer call() throws Exception {
		        int sum = 0;
		        for (int i = 1; i <= 5; i++) {
		            sum += i;
		        }
		        return sum; // Возвращаем результат
		    }
		}
		```
	- можно как я описал как и в случае с **Runnable** сделать лямбду
11. Что такое `ExecutorService` и как он помогает в управлении потоками?
	- До появления ExecutorService, мы часто писали так:
		```java
		public static void main(String[] args) {
		    new Thread(() -> System.out.println("Выполняю задачу...")).start();
		}
		```
	- Это работает, но у такого подхода есть серьёзные минусы: - каждый Thread создаётся заново → дорого по ресурсам; - сложно контролировать, сколько потоков работает одновременно; - невозможно корректно завершить все потоки в конце программы; - сложно получать результаты работы задач и обрабатывать ошибки.
	- **ExecutorService** — это высокоуровневый механизм управления потоками, предоставляемый в пакете java.util.concurrent.
	- Когда ты создаёшь ExecutorService, например
		```java
		public static void main(String[] args) {
		    ExecutorService executor = Executors.newFixedThreadPool(3);
		}
		```
	- Под капотом происходит следующее:
	    - создаются 3 рабочих потока;
	    - эти потоки не завершаются после выполнения первой задачи — они ждут следующих;
	    - все задачи, поданные через executor.submit(...) или executor.execute(...), помещаются в очередь задач;
	    - ExecutorService сам решает, когда и каким потоком выполнить каждую задачу.
		- Так реализуется переиспользование потоков и оптимизация ресурсов.
	- Java предоставляет несколько стандартных фабричных методов:
	    - `Executors.newFixedThreadPool(n)` — идеально для ограниченного набора задач // фиксированное количество потоков
	    - `Executors.newCachedThreadPool()` — хорошо, когда количество задач непредсказуемо // динамическое: создаёт новые при необходимости
	    - `Executors.newSingleThreadExecutor()` — когда порядок выполнения важен // только один поток
	    - `Executors.newScheduledThreadPool(n)` — для периодического запуска (например, каждые 5 секунд) // для планирования задач (аналог таймера)
	- ExecutorService принимает задачи двумя основными способами:
	    - execute(Runnable task)
	        - ничего не возвращает;
	        - подходит, если результат не нужен.
	    - submit(Callable task)
	        - возвращает Future — объект для получения результата;
	        - используется, если нужно вернуть значение или обработать исключение.

		```java
		public static void main(String[] args) {
		    Future<Integer> result = executor.submit(() -> {
		        Thread.sleep(1000);
		        return 42;
		    });
		    System.out.println("Результат: " + result.get());
		}
		```

	- Важно всегда корректно завершать работу `ExecutorService`. Иначе программа может зависнуть, так как потоки-помощники всё ещё активны.
		- executor.shutdown();` // Запрещает приём новых задач, ждёт завершения текущих
	    - `executor.awaitTermination(5, TimeUnit.SECONDS);` // Ждёт максимум 5 секунд
	    - `executor.shutdownNow();`// Принудительно прерывает все задачи
12. Какую роль играет `submit()` метод в `ExecutorService`?
	- описал выше
    - `boolean future.cancel(true)`
        - Если задача ещё не началась → она удаляется из очереди, и не будет выполнена.
        - Если задача уже выполняется → вызывается Thread.interrupt() для потока, в котором она запущена.
        - `cancel(true)` не “убивает” поток насильно — она просто устанавливает флаг прерывания.
        - Чтобы это сработало, задача должна проверять прерывание (например, ловить `InterruptedException` при `sleep()`,`wait()` или вручную проверять `Thread.currentThread().isInterrupted())`.
13. Как обработать исключения, выбрасываемые задачей `Callable`?
	```java
	public static void main(String[] args) {
	    ExecutorService executor = Executors.newSingleThreadExecutor();
	    Future<Integer> future = executor.submit(() -> {
	        System.out.println("Начинаю задачу...");
	        if (true) throw new RuntimeException("Ошибка в задаче!");
	        return 10;
	    });
	
	    try {
	        Integer result = future.get(); // тут выбросится ExecutionException
	    } catch (ExecutionException e) {
	        System.err.println("Исключение из задачи: " + e.getCause()); // Получаем оригинальное исключение
	    } catch (InterruptedException e) {
	        Thread.currentThread().interrupt();
	        System.err.println("Поток был прерван");
	    }
	    executor.shutdown();
	}
	```
	- примечательно, что мы увидим исключение в основном потоке только тогда, когда вызовем `get()` на future
	- `future.get()` - так же блокирует поток до тех пор пока задача не будет выполнена и не вернет результат
#### ThreadPools:
14. Почему использование пулов потоков может улучшить производительность приложения?
	- Пулы потоков решают эти проблемы:
		- Переиспользование потоков → потоки создаются один раз и потом многократно выполняют новые задачи.
		- Ограничение числа активных потоков → предотвращает перегрузку CPU и нехватку памяти.
		- Упрощение управления → не нужно вручную вызывать start(), ждать завершения, отслеживать ошибки и т.д.
		- Улучшенная отзывчивость → задачи ставятся в очередь и выполняются по мере освобождения потоков.
15. Какие предустановленные реализации `ThreadPool` предоставляет Java?
    - описал выше (вопрос 11)
16. Как `FixedThreadPool` отличается от `CachedThreadPool`?
	- **newCachedThreadPool()** - Потоки создаются по мере необходимости и переиспользуются. Если поток не используется 60 секунд — удаляется.
	- **FixedThreadPool**
	    - Количество потоков - Фиксировано (n)
	    - Очередь задач - Есть (LinkedBlockingQueue)
	    - Использование - Долгие задачи, стабильная нагрузка
	    - Поведение при перегрузке - Задачи ждут в очереди
	- **CachedThreadPool**
	    - Количество потоков - Меняется динамически
	    - Очередь задач - Почти нет очереди — создаются новые потоки
	    - Использование - Короткие, частые задачи, непредсказуемая нагрузка
	    - Поведение при перегрузке - Создаёт новые потоки (может привести к избытку)
	- Веб-сервер с ограниченным числом клиентов → **FixedThreadPool**.
	- Микросервис с непредсказуемыми короткими запросами → **CachedThreadPool**.
17. Как выбрать подходящий размер пула потоков для приложения?
	- если нагрузка постоянная, то нет смысла делать потоков больше чем ядер в процессоре, тогда будет частое переключение между ними, а это затратная операция
	- если нагрузка непостоянная или много ожидания, то потоков можно сделать больше, чем ядер
	- `nThreads ≈ cores * (1 + время_ожидания / время_работы)`
#### Future и CompletableFuture:
18. Что такое интерфейс `Future` и как он используется для получения результатов асинхронных задач?
	- `Future<V>` — это интерфейс из пакета java.util.concurrent, который представляет результат асинхронной задачи (может ещё не завершиться).
	- Основные методы `Future`
	    - `get()` - Блокирует текущий поток, пока задача не завершится, и возвращает результат
	    - `get(long timeout, TimeUnit unit)` - То же самое, но с таймаутом, иначе выбросится `java.util.concurrent.TimeoutException`
	    - `isDone()` - Проверяет, завершилась ли задача
	    - `boolean cancel(boolean mayInterruptIfRunning)`
	        - если передаем _true_, и поток еще не завершился, то вызывает у потока `interrupt()` и возвращает _true_, иначе _false_
	        - если передадим _false_ и поток еще не завершился и работает, то вернет _false_, иначе если поток еще не начал свое выполнение и стоит в очереди, то не даст ему начать и вернет _true_
	        - Если задача ещё не стартовала
	            - Future\<?\> future = executor.submit(task);
	            - future.cancel(false);
	            - future.isCancelled(); // true
	        - Если задача уже выполняется
	            - cancel(false) → поток уже выполняется, отмена не применяется → isCancelled() false, потому что задача не была отменена реально.
	            - cancel(true) → поток получает interrupt(). Если задача прерывается корректно → isCancelled() → true, иначе false (если поток игнорирует прерывание).
	            - Если задача уже завершилась к моменту вызова cancel() вернет False
	        - `isCancelled()` - отражает результат вызова метода `cancel()`
		```java
		import java.util.concurrent.*;
		
		public class FutureCancelExample {
		    public static void main(String[] args) throws InterruptedException {
		        ExecutorService executor = Executors.newFixedThreadPool(2);
		
		        // 1. Создаём задачу
		        Runnable task = () -> {
		            try {
		                for (int i = 0; i < 5; i++) {
		                    System.out.println("Task running: " + i);
		                    Thread.sleep(1000); // имитация долгой работы
		                }
		            } catch (InterruptedException e) {
		                System.out.println("Task was interrupted!");
		            }
		        };
		
		        // 2. Отправляем задачу в пул потоков
		        Future<?> future = executor.submit(task);
		
		        // 3. Через 2 секунды пытаемся отменить задачу
		        Thread.sleep(2000);
		        boolean cancelled = future.cancel(false); // false → не прерывать, только если ещё не началась
		        System.out.println("Cancelled: " + cancelled);
		
		        executor.shutdown();
		    }
		}
		```
19.  Как `CompletableFuture` расширяет возможности `Future`?
	- `ForkJoinPool` — это специальная реализация пула потоков (thread pool), появившаяся в Java 7. Он создан для эффективного выполнения большого количества мелких асинхронных задач. В отличие от обычного ThreadPoolExecutor, ForkJoinPool:
	    - умеет делить задачи на подзадачи (fork);
	    - объединять результаты (join);
	    - использует work-stealing — потоки крадут задачи друг у друга, чтобы не простаивать.
	- он используется если не передать самостоятельно пул потоков в `CompletableFuture`
	- более того, `CompletableFuture` позволяет вызвать цепочку методов, которые не блокируют поток в котором они вызываются, то есть:
	    - у `CompletableFuture` - `join()` блокирует выполнение потока пока future не будет выполнена
	    - у `Future` - ~~join()~~ не существует, есть `get()` - аналог `join()`
	- Как получить и обработать результаты выполения потока (асинхронной задачи) не блокируя основной поток, для этого есть методы `CompletableFuture`:
	    - `getNow(defaultValue)` — возвращает результат, если готов, иначе — defaultValue, без ожидания
	    - `thenApply(Function<T,R>)` — трансформирует результат
	    - `thenAccept(Consumer<T>)` — выполняет действие с результатом, ничего не возвращает
	    - `thenRun(Runnable)` — выполняет действие после завершения, не использует результат
	    - из всего этого можно сделать цепочку, которая не блокирует исполнение строчек кода после нее
	    - **НО** Вся цепочка может выполняться в том же потоке, где завершилась предыдущая задача, если использовать обычный `then...()`
	        - это не дает остальным задачам выполняться продолжительное время, если нет других свободных потоков, и чтоы разгрузить и дать возможность выполняться другим задачам можно испольхзовать `thenApplyAsync()`, `thenAcceptAsync()`, `thenRunAsync()`, тогад каждый из шагов будет поставлен в очередь и может быть выполнен в дургом потоке

		```java
		public static void main(String[] args) {
		    CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 10);
		
		    CompletableFuture<Integer> doubled = future.thenApply(x -> x * 2);
		
		    doubled.thenAccept(System.out::println); // Вывод: 20
		
		    CompletableFuture<Void> future = CompletableFuture.supplyAsync(() -> "Hello")
		            .thenRun(() -> System.out.println("Задача завершена"));
		}
		```
20. Как использовать `thenApply()` для обработки завершенного результата в `CompletableFuture`?
	```java
	public static void main(String[] args) {
	    CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 10);
	
	    CompletableFuture<Integer> doubled = future.thenApply(x -> x * 2);
	
	    doubled.thenAccept(System.out::println); // Вывод: 20
	
	    CompletableFuture<Void> future = CompletableFuture.supplyAsync(() -> "Hello")
	            .thenRun(() -> System.out.println("Задача завершена"));
	}
	```
21. В чем разница между `runAsync()` и `supplyAsync()`?
	- `CompletableFuture<Void> runAsync(Runnable)` - нифига не возвращает
	- `CompletableFuture<T> supplyAsync(Supplier<T>)` - Когда нужно получить результат от асинхронной задачи
#### runAsync:
22. Как `runAsync()` используется для запуска задач в `CompletableFuture`?
23. Приведите пример использования `runAsync()` для выполнения задачи без возвращаемого результата.

### Дополнительные механизмы:
#### CountDownLatch

24. Как работает `CountDownLatch` и в каких случаях его можно использовать?
25. Приведите пример использования `CountDownLatch` для ожидания выполнения нескольких потоков.

#### ReentrantLock

26. Когда следует использовать `ReentrantLock`, а не `synchronized`?
27. Как работает метод `lockInterruptibly()` в `ReentrantLock`?
28. Какие методы в `ReentrantLock` позволяют попытаться захватить блокировку?

#### CyclicBarrier

29. Что такое `CyclicBarrier`, и как он отличается от `CountDownLatch`?
30. Как `CyclicBarrier` помогает координировать выполнение группы потоков?

#### Exchanger

31. Как `Exchanger` используется для обмена данными между двумя потоками?
32. Приведите пример использования `Exchanger` для передачи данных между потоками.

### Асинхронное и параллельное программирование:

#### ForkJoinPool

33. Что такое `ForkJoinPool` и как он используется для параллельных вычислений?
34. Как `RecursiveTask` и `RecursiveAction` используются с `ForkJoinPool`?

#### Асинхронное программирование с CompletableFuture

35. Как построить цепочку асинхронных задач с `CompletableFuture`?
36. Как работают комбинированные операции, такие как `thenCombine()` в `CompletableFuture`?

### Потокобезопасные коллекции и инструменты:

37. Какие коллекции из `java.util.concurrent` являются потокобезопасными?
38. Как использовать `ConcurrentHashMap` для управления конкурентным доступом?
39. Что такое `ThreadLocal` и как он позволяет создавать поток-локальные переменные?

### Концепции производительности и оптимизации:

#### Производитель-Потребитель

40. Что такое шаблон "Производитель-Потребитель"?
41. Как реализовать шаблон "Производитель-Потребитель" с помощью семафоров или блокирующих очередей?

#### Оптимизация пула потоков и мониторинг

42. Как выбрать подходящий размер пула потоков для конкретного приложения?
43. Какие инструменты и практики применяются для мониторинга и оптимизации многопоточных приложений?

### Примеры и кейсы:

#### Реальные сценарии использования многопоточности

44. Какие практические применения многопоточности вы знаете в обработке данных?
45. Как многопоточность помогает в разработке высокопроизводительных сетевых приложений?

#### Практические задачи

46. Как реализовать многопоточное решение для объединения нескольких источников данных?
47. Какие проблемы возникают при использовании потоков в распределенных приложениях?
48. Приведите пример использования `ForkJoinPool` для расчета суммарного значения в большом массиве.
49. Как использовать `CompletableFuture` для асинхронного чтения данных из нескольких источников?
50. Какие преимущества и недостатки асинхронного программирования в сравнении с традиционным, синхронным подходом?