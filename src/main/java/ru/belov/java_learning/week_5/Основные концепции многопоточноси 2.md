

### Современный API для многопоточности:

#### Atomic операции:
1. Что такое атомарные операции и какие классы предоставляет Java для их реализации?
   - Это неделимые операции, которые состоят из нескольких шагов, выполняются в одной транзакции и не могут быть прерваны другими потоками.
   - Классы:
     - ReentrantLock - более удобный и гибкий, чем synchronized блок кода
     - AtomicInteger - для работы с целочисленными переменными
     - AtomicBoolean - для работы с булевыми переменными
     - AtomicDoubleAccumulator
     - AtomicIntegerArray
       AtomicLongArray
       AtomicReferenceArray<T>
     - всякие потокобезопасные коллекции
   - Операция increment (увеличения значения) на самом деле не атомарна и она состоит из 3 шагов:
     - загрузить значение переменной из памяти
     - изменить значение как `old + delta`, в этот момент old может измениться 
     - сохранить новое значение в память
   - так вот, все Atomic классы используют специальные инструкции процессора, которые гарантируют, что операция increment будет атомарной.
     Compare-And-Swap (CAS) — сравнивает текущее значение в памяти с ожидаемым, и если они совпадают, заменяет его на новое. Всё это выполняется атомарно на уровне процессора.
2. Как работает класс `AtomicInteger` и в чем его преимущество над стандартными целочисленными переменными?
    - Методы класса:
      - `get()` → делает volatile read (внутри класс имеет `volatile int value`)
      - `set(int newValue)` → делает volatile write
      - `lazySet(int newValue)` → делает weaker volatile write (отложенный, но всё равно атомарный)
      - `incrementAndGet()` — увеличить на 1, вернуть новое значение. 
      - `getAndIncrement()` — увеличить на 1, вернуть старое значение. 
      - `decrementAndGet()` — уменьшить на 1, вернуть новое значение. 
      - `getAndDecrement()` — уменьшить на 1, вернуть старое значение.
      - Методы `addAndGet(int delta)` и `getAndAdd(int delta)` реализованы через CAS (Compare-And-Swap) в цикле.
      - псевдокод для данных операций 
      ```java
        public static void main(String[] args){
            int prev, next;
            do {
                prev = get();            // volatile read
                next = prev + delta;     // локальный расчёт
            } while (!compareAndSet(prev, next));  // CAS
            return next;
        }
        ```
      - `boolean compareAndSet(int expect, int update)` — если текущее значение равно expect, то обновить его на update. Возвращает true/false.
      - `getAndUpdate(IntUnaryOperator updateFunction)` — применить функцию, вернуть старое значение. 
      - `updateAndGet(IntUnaryOperator updateFunction)` — применить функцию, вернуть новое значение.
        - `getAndUpdate()` и `updateAndGet()` - также работают с использованием механизма CAS
        - Поток берёт текущее значение.
        - Применяет функцию.
        - Пытается обновить с помощью CAS.
        - Если другой поток успел изменить значение, CAS проваливается, и цикл повторяется.
        - В итоге операция атомарна, но может «покрутиться» в цикле несколько раз. Пример
        ```java
          public void addEnergy(){
            energyReserve.updateAndGet(cur -> {
                    if (cur + energyToAdd > MAX_ENERGY_RESERVE) {
                        return MAX_ENERGY_RESERVE;
                    } else {
                        return cur + energyToAdd;
                    }
            });
          }
          ```
3. Как `compareAndSet()` используется для реализации атомарного обновления?
    - если текущее значение равно expect, то обновить его на update. Возвращает true/false.
    - то есть если кто-то до этого успел поменять значение, то оно не обновится
    - есть различные _weak-методы_, которые могут провалится, вернув false, даже если условие выполнено, например
      - `weakCompareAndSet(int expect, int update)` - Может иногда не сработать даже если текущее значение равно ожидаемому.
      - **Зачем?** - потенциально насколько я понимаю операция выполняется быстрее, что дает прирост производительности
      в алгоритмах, где допустимы такие провалы.
4. Приведите пример использования `AtomicLong` для безопасного параллельного инкремента.
```java
import java.util.concurrent.atomic.AtomicLong;

public class AtomicLongExample {
    private static AtomicLong counter = new AtomicLong(0);

    public static void main(String[] args) throws InterruptedException {
        int numThreads = 5;
        int incrementsPerThread = 1000;

        Thread[] threads = new Thread[numThreads];

        for (int i = 0; i < numThreads; i++) {
            threads[i] = new Thread(() -> {
                for (int j = 0; j < incrementsPerThread; j++) {
                    counter.incrementAndGet();  // или counter.getAndIncrement()
                }
            });
            threads[i].start();
        }

        for (Thread t : threads) {
            t.join();
        }

        System.out.println("Окончательное значение счетчика: " + counter.get());
    }
}

```

#### Lock:

5. Чем `ReentrantLock` отличается от использования ключевого слова `synchronized`?
   - есть возможность попытки захвата без ожидания в случае не удачи, для этого есть метод `tryLock()` 
   - есть функция таймаута `boolean tryLock(timeout, TimeUnit)`
   - Нужно явно вызывать `unlock()` (обычно в finally)
6. Как `ReentrantLock` обрабатывает рекурсивные блокировки?
   - `ReentrantLock` как и `synchronized` имеет счетчик, при рекурсии он увеличивается, главное не забывать делать unlock()
7. Зачем использовать `tryLock()` вместо `lock()`?
   - выполнение альтернативного сценария, не блокируя поток, банально завершить выполнение метода например, чтобы не блокировать поток.
8. Как `ReadWriteLock` помогает в многопоточной среде?
   - По факту происходит разделение lock на два
     - читатель: `rwLock.readLock().lock()`
       - когда он блокировка произошла другие читатели также могут захватывать lock путем `rwLock.readLock().lock()`
       - однако писатель не сможет писать и при вызове `rwLock.writeLock().lock()` уйдет в ожидание
     - писатель: `rwLock.writeLock().lock()`
       - блокирует доступ и читателям и писателям, так что все они уйдут в ожидание 

#### Callable, Task и Executors:

9. Что такое интерфейс `Callable` и как он отличается от `Runnable`?
    - Позволяет создавать задачи, которые возвращают результат и могут выбрасывать проверяемые исключения.

| Особенность           | Runnable                         | Callable                                                      |
| --------------------- | -------------------------------- | ------------------------------------------------------------- |
| Возвращаемое значение | `void`                           | `V` (объект любого типа)                                      |
| Исключения            | Может выбросить только unchecked | Может выбросить любые checked/unchecked(заложено в сигнатуру) |
| Метод                 | `run()`                          | `call()`                                                      |
   - ```java
     public static void main(String[] args){
         Callable<Integer> task = () -> {
            Thread.sleep(1000);
            return 52;
        };
     }
     ```

10. Как создать задачу, возвращающую результат, с помощью `Callable`?
    - Можно как и в случае с **Runnable** имплементировать интерфейс
```java
import java.util.concurrent.Callable;

public class MyCallable implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        int sum = 0;
        for (int i = 1; i <= 5; i++) {
            sum += i;
        }
        return sum; // Возвращаем результат
    }
}

```
- можно как я описал как и в случае с **Runnable** сделать лямбду

11. Что такое `ExecutorService` и как он помогает в управлении потоками?
До появления ExecutorService, мы часто писали так:
```java
public static void main(String[] args) {
    new Thread(() -> System.out.println("Выполняю задачу...")).start();
}
```
Это работает, но у такого подхода есть серьёзные минусы:
    - каждый Thread создаётся заново → дорого по ресурсам;
    - сложно контролировать, сколько потоков работает одновременно;
    - невозможно корректно завершить все потоки в конце программы;
    - сложно получать результаты работы задач и обрабатывать ошибки.
- **ExecutorService** — это высокоуровневый механизм управления потоками, предоставляемый в пакете java.util.concurrent.
- Когда ты создаёшь ExecutorService, например

```java
public static void main(String[] args) {
    ExecutorService executor = Executors.newFixedThreadPool(3);
}
```
- Под капотом происходит следующее:
    - создаются 3 рабочих потока;
    - эти потоки не завершаются после выполнения первой задачи — они ждут следующих;
    - все задачи, поданные через executor.submit(...) или executor.execute(...), помещаются в очередь задач;
    - ExecutorService сам решает, когда и каким потоком выполнить каждую задачу.
- Так реализуется переиспользование потоков и оптимизация ресурсов.
- Java предоставляет несколько стандартных фабричных методов:
    - `Executors.newFixedThreadPool(n)` — идеально для ограниченного набора задач // фиксированное количество потоков
    - `Executors.newCachedThreadPool()` — хорошо, когда количество задач непредсказуемо // динамическое: создаёт новые при необходимости
    - `Executors.newSingleThreadExecutor()` — когда порядок выполнения важен // только один поток
    - `Executors.newScheduledThreadPool(n)` — для периодического запуска (например, каждые 5 секунд) // для планирования задач (аналог таймера)
- ExecutorService принимает задачи двумя основными способами:
  - execute(Runnable task)
    - ничего не возвращает;
    - подходит, если результат не нужен.
  - submit(Callable<V> task)
    - возвращает Future<V> — объект для получения результата;
    - используется, если нужно вернуть значение или обработать исключение.

```java
public static void main(String[] args) {
    Future<Integer> result = executor.submit(() -> {
        Thread.sleep(1000);
        return 42;
    });
    System.out.println("Результат: " + result.get());
}
```
- Важно всегда корректно завершать работу `ExecutorService`. Иначе программа может зависнуть, так как потоки-помощники всё ещё активны.
  - `executor.shutdown();` // Запрещает приём новых задач, ждёт завершения текущих
  - `executor.awaitTermination(5, TimeUnit.SECONDS);` // Ждёт максимум 5 секунд
  - `executor.shutdownNow();`// Принудительно прерывает все задачи

12. Какую роль играет `submit()` метод в `ExecutorService`?
    - описал выше
    - `boolean future.cancel(true)`
      - Если задача ещё не началась → она удаляется из очереди, и не будет выполнена.
      - Если задача уже выполняется → вызывается Thread.interrupt() для потока, в котором она запущена.
      - `cancel(true)` не “убивает” поток насильно — она просто устанавливает флаг прерывания.
      - Чтобы это сработало, задача должна проверять прерывание (например, ловить `InterruptedException` при `sleep()`,
      `wait()` или вручную проверять `Thread.currentThread().isInterrupted())`.

13. Как обработать исключения, выбрасываемые задачей `Callable`?

```java
public static void main(String[] args) {
    ExecutorService executor = Executors.newSingleThreadExecutor();
    Future<Integer> future = executor.submit(() -> {
        System.out.println("Начинаю задачу...");
        if (true) throw new RuntimeException("Ошибка в задаче!");
        return 10;
    });

    try {
        Integer result = future.get(); // тут выбросится ExecutionException
    } catch (ExecutionException e) {
        System.err.println("Исключение из задачи: " + e.getCause()); // Получаем оригинальное исключение
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        System.err.println("Поток был прерван");
    }
    executor.shutdown();
}
```

#### ThreadPools:

14. Почему использование пулов потоков может улучшить производительность приложения?
- Пулы потоков решают эти проблемы:
- Переиспользование потоков 
  - → потоки создаются один раз и потом многократно выполняют новые задачи.
- Ограничение числа активных потоков
  - → предотвращает перегрузку CPU и нехватку памяти.
- Упрощение управления
  - → не нужно вручную вызывать start(), ждать завершения, отслеживать ошибки и т.д.
- Улучшенная отзывчивость
  - → задачи ставятся в очередь и выполняются по мере освобождения потоков.
15. Какие предустановленные реализации `ThreadPool` предоставляет Java?
    - описал выше
16. Как `FixedThreadPool` отличается от `CachedThreadPool`?
- **newCachedThreadPool()** - Потоки создаются по мере необходимости и переиспользуются. Если поток не используется 60 секунд — удаляется.
- **FixedThreadPool**
  - Количество потоков - Фиксировано (n)
  - Очередь задач - Есть (LinkedBlockingQueue)
  - Использование - Долгие задачи, стабильная нагрузка
  - Поведение при перегрузке - Задачи ждут в очереди
- **CachedThreadPool**
  - Количество потоков - Меняется динамически
  - Очередь задач - Почти нет очереди — создаются новые потоки
  - Использование - Короткие, частые задачи, непредсказуемая нагрузка
  - Поведение при перегрузке - Создаёт новые потоки (может привести к избытку)
- Веб-сервер с ограниченным числом клиентов → **FixedThreadPool**.
- Микросервис с непредсказуемыми короткими запросами → **CachedThreadPool**.

17. Как выбрать подходящий размер пула потоков для приложения?
- если нагрузка постоянная, то нет смысла делать потоков больше чем ядер в процессоре, тогда будет частое переключение между ними,
а это затратная операция
- если нагрузка непостоянная или много ожидания, то потоков можно сделать больше, чем ядер 
- `nThreads ≈ cores * (1 + время_ожидания / время_работы)`

#### Future и CompletableFuture:
18. Что такое интерфейс `Future` и как он используется для получения результатов асинхронных задач?
- `Future<V>` — это интерфейс из пакета java.util.concurrent, 
который представляет результат асинхронной задачи (может ещё не завершиться).
- Основные методы `Future`
  - `get()` - Блокирует текущий поток, пока задача не завершится, и возвращает результат
  - `get(long timeout, TimeUnit unit)` - То же самое, но с таймаутом, иначе выбросится `java.util.concurrent.TimeoutException`
  - `isDone()` - Проверяет, завершилась ли задача
  - `boolean cancel(boolean mayInterruptIfRunning)` 
    - если передаем _true_, и поток еще не завершился, то вызывает у потока `interrupt()` и возвращает _true_, иначе _false_ 
    - если передадим _false_ и поток еще не завершился и работает, то вернет _false_, иначе если поток еще не начал свое выполнение и стоит в очереди,
    то не даст ему начать и вернет _true_ 
    - Если задача ещё не стартовала
      - Future<?> future = executor.submit(task);
      - future.cancel(false);
      - future.isCancelled(); // true
    - Если задача уже выполняется
      - cancel(false) → поток уже выполняется, отмена не применяется → isCancelled() false, потому что задача не была отменена реально.
      - cancel(true) → поток получает interrupt(). Если задача прерывается корректно → isCancelled() → true, иначе false (если поток игнорирует прерывание).
      - Если задача уже завершилась к моменту вызова cancel() вернет False
    - `isCancelled()` - отражает результат вызова метода `cancel()`
```java
import java.util.concurrent.*;

public class FutureCancelExample {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        // 1. Создаём задачу
        Runnable task = () -> {
            try {
                for (int i = 0; i < 5; i++) {
                    System.out.println("Task running: " + i);
                    Thread.sleep(1000); // имитация долгой работы
                }
            } catch (InterruptedException e) {
                System.out.println("Task was interrupted!");
            }
        };

        // 2. Отправляем задачу в пул потоков
        Future<?> future = executor.submit(task);

        // 3. Через 2 секунды пытаемся отменить задачу
        Thread.sleep(2000);
        boolean cancelled = future.cancel(false); // false → не прерывать, только если ещё не началась
        System.out.println("Cancelled: " + cancelled);

        executor.shutdown();
    }
}

```

19. Как `CompletableFuture` расширяет возможности `Future`?
- `ForkJoinPool` — это специальная реализация пула потоков (thread pool), появившаяся в Java 7.
    Он создан для эффективного выполнения большого количества мелких асинхронных задач.
    В отличие от обычного ThreadPoolExecutor, ForkJoinPool:
  - умеет делить задачи на подзадачи (fork);
  - объединять результаты (join);
  - использует work-stealing — потоки крадут задачи друг у друга, чтобы не простаивать.
- он используется если не передать самостоятельно пул потоков в `CompletableFuture` 
- более того, `CompletableFuture` позволяет вызвать цепочку методов, которые не блокируют поток в котором они вызываются,
то есть:
  - у `CompletableFuture` - `join()` блокирует выполнение потока пока future не будет выполнена
  - у `Future` - ~~join()~~ не существует, есть `get()` - аналог `join()`
- Как получить и обработать результаты выполения потока (асинхронной задачи) не блокируя основной поток, для этого есть методы
  `CompletableFuture`:
  - `getNow(defaultValue)` — возвращает результат, если готов,
    иначе — defaultValue, без ожидания
  - `thenApply(Function<T,R>)` — трансформирует результат
  - `thenAccept(Consumer<T>)` — выполняет действие с результатом, ничего не возвращает
  - `thenRun(Runnable)` — выполняет действие после завершения, не использует результат
  - из всего этого можно сделать цепочку, которая не блокирует исполнение строчек кода после нее
  - **НО** Вся цепочка может выполняться в том же потоке, где завершилась предыдущая задача, если использовать обычный `then...()`
    - это не дает остальным задачам выполняться продолжительное время, если нет других свободных потоков, и чтоы разгрузить
    и дать возможность выполняться другим задачам можно испольхзовать `thenApplyAsync()`, `thenAcceptAsync()`, `thenRunAsync()`,
    тогад каждый из шагов будет поставлен в очередь и может быть выполнен в дургом потоке
```java
public static void main(String[] args) {
    CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 10);

    CompletableFuture<Integer> doubled = future.thenApply(x -> x * 2);

    doubled.thenAccept(System.out::println); // Вывод: 20

    CompletableFuture<Void> future = CompletableFuture.supplyAsync(() -> "Hello")
            .thenRun(() -> System.out.println("Задача завершена"));
}
```

20. Как использовать `thenApply()` для обработки завершенного результата в `CompletableFuture`?

```java
public static void main(String[] args) {
    CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 10);

    CompletableFuture<Integer> doubled = future.thenApply(x -> x * 2);

    doubled.thenAccept(System.out::println); // Вывод: 20

    CompletableFuture<Void> future = CompletableFuture.supplyAsync(() -> "Hello")
            .thenRun(() -> System.out.println("Задача завершена"));
}
```

21. В чем разница между `runAsync()` и `supplyAsync()`?
- `CompletableFuture<Void> runAsync(Runnable)` - нифига не возвращает
- `CompletableFuture<T> supplyAsync(Supplier<T>)` - Когда нужно получить результат от асинхронной задачи

#### runAsync:

22. Как `runAsync()` используется для запуска задач в `CompletableFuture`?
23. Приведите пример использования `runAsync()` для выполнения задачи без возвращаемого результата.

### Дополнительные механизмы:

#### CountDownLatch

24. Как работает `CountDownLatch` и в каких случаях его можно использовать?
25. Приведите пример использования `CountDownLatch` для ожидания выполнения нескольких потоков.

#### ReentrantLock

26. Когда следует использовать `ReentrantLock`, а не `synchronized`?
27. Как работает метод `lockInterruptibly()` в `ReentrantLock`?
28. Какие методы в `ReentrantLock` позволяют попытаться захватить блокировку?

#### CyclicBarrier

29. Что такое `CyclicBarrier`, и как он отличается от `CountDownLatch`?
30. Как `CyclicBarrier` помогает координировать выполнение группы потоков?

#### Exchanger

31. Как `Exchanger` используется для обмена данными между двумя потоками?
32. Приведите пример использования `Exchanger` для передачи данных между потоками.

### Асинхронное и параллельное программирование:

#### ForkJoinPool

33. Что такое `ForkJoinPool` и как он используется для параллельных вычислений?
34. Как `RecursiveTask` и `RecursiveAction` используются с `ForkJoinPool`?

#### Асинхронное программирование с CompletableFuture

35. Как построить цепочку асинхронных задач с `CompletableFuture`?
36. Как работают комбинированные операции, такие как `thenCombine()` в `CompletableFuture`?

### Потокобезопасные коллекции и инструменты:

37. Какие коллекции из `java.util.concurrent` являются потокобезопасными?
38. Как использовать `ConcurrentHashMap` для управления конкурентным доступом?
39. Что такое `ThreadLocal` и как он позволяет создавать поток-локальные переменные?

### Концепции производительности и оптимизации:

#### Производитель-Потребитель

40. Что такое шаблон "Производитель-Потребитель"?
41. Как реализовать шаблон "Производитель-Потребитель" с помощью семафоров или блокирующих очередей?

#### Оптимизация пула потоков и мониторинг

42. Как выбрать подходящий размер пула потоков для конкретного приложения?
43. Какие инструменты и практики применяются для мониторинга и оптимизации многопоточных приложений?

### Примеры и кейсы:

#### Реальные сценарии использования многопоточности

44. Какие практические применения многопоточности вы знаете в обработке данных?
45. Как многопоточность помогает в разработке высокопроизводительных сетевых приложений?

#### Практические задачи

46. Как реализовать многопоточное решение для объединения нескольких источников данных?
47. Какие проблемы возникают при использовании потоков в распределенных приложениях?
48. Приведите пример использования `ForkJoinPool` для расчета суммарного значения в большом массиве.
49. Как использовать `CompletableFuture` для асинхронного чтения данных из нескольких источников?
50. Какие преимущества и недостатки асинхронного программирования в сравнении с традиционным, синхронным подходом?



