### Основные концепции многопоточности
1. Что такое поток (`Thread`) в Java?
   - поток - единица выполнения, которая может работать **отдельно**, параллельно с другими такими же потоками. 
   - Каждый поток представляет собой последовательность действий в виде кода в рамках одного процесса.
2. Каковы основные различия между `Runnable` и `Thread`?
    - `Thread` принимает в себя `Runnable`, представляет собой по сути обертку над `Runnable`, которая позволяет
запускать то что написано в методе `run()` у объекта интерфейса `Runnable`
    - `Runnable` - функциональный интерфейс с методом `run()` 
3. Как создать поток с использованием интерфейса Runnable?
```java
        public static void main(String[] args) {
        Thread thread = new Thread("мой поток", () -> {
            System.out.println("опа");});
        }
```
4. Как создать поток, наследуя от класса Thread?
```java
public class MyThread extends Thread {

    @Override
    public void run() {
        System.out.println("Задача 1 | Работает MyThread унаследованный от Thread");
    }
}
```
5. Что произойдет, если вызвать метод start() более одного раза на одном потоке? 

Будет выброшено `java.lang.IllegalThreadStateException`

6. Чем отличается запуск потока через метод start() от вызова метода run() напрямую?
   - при запуске потока через метод `start()` действия будут выполняться в отдельном, а при вызове 
через метод `run()` действия будут выполняться в том же потоке, в котором был вызван метод

7. Какие преимущества использования Runnable вместо Thread?

Кажется он как раз существует, чтобы отделять действие от управления-запуска этого действия, что позволяет
передавать это действие в несколько потоков например.
8. Каковы основные отличия между main thread и другими потоками?
    - невозможно сделать демоном `setDaemon(true)` вызовет ошибку
    - создается автоматически JVM при запуске `main()`
    - Если main завершён, программа останавливается, если не осталось активных non-daemon потоков
9. Что такое daemon thread и когда их следует использовать?

   - JVM завершает работу, как только все обычные (non-daemon) потоки завершены, даже если фоновые потоки ещё работают.
   - демон потоки при этом убиваются, JVM не гарантирует их корректное завершение

Daemon-потоки нужны там, где поток выполняет вспомогательные задачи и не должен мешать завершению основной программы.
   - Асинхронный сбор логов 
   
      Некоторые логгер-фреймворки (например, Logback, Log4j2) могут работать асинхронно:
      Основной поток просто складывает сообщение в очередь.
      Отдельный поток-работник (часто daemon) берёт записи из очереди и пишет их в файл/сеть.
      
      Зачем так делать?
      - Чтобы логирование не тормозило бизнес-логику.
      - Основной поток не ждёт дисковых операций

   - Фоновая очистка / кеширование

      Например, удаление временных данных или управление кэшем, чтобы он не разрастался
      Допустим, у тебя есть кэш для часто используемых данных (например, результаты SQL-запросов).
      Основные потоки работают с кэшем: положили объект — достали объект.
      Чтобы кэш не разрастался до бесконечности, запускается фоновой поток, который:
      периодически проверяет "возраст" или "вес" объектов,
      удаляет устаревшие или самые редко используемые.

10. Можно ли сделать главный поток демоном?
    - **нет**
### Запуск потоков:

11. Как происходит переключение контекста между потоками?
    - Что такое контекст потока?
    У каждого потока есть свой контекст — это набор данных, которые позволяют "заморозить" и "возобновить" его выполнение:
    значения регистров процессора (указатель на текущую инструкцию, стековый указатель и т. д.),
    содержимое стека вызовов (где лежат локальные переменные и параметры методов),
    информация о планировщике (состояние: running, waiting, blocked, ready).
    -  Как происходит переключение?
    Планировщик ОС решает, какой поток сейчас будет работать
    Java не управляет потоками напрямую — это делает ОС. JVM просто просит у ОС: «Создай поток», а дальше ОС решает, когда его запускать.
    Останавливается текущий поток
    ОС сохраняет его состояние (регистры, стек, счетчик инструкций) в структуре данных — контекст.
    Поток переводится в состояние "готов" (ready) или "ожидание" (waiting), если он заблокирован (например, ждёт монитор или I/O).
    Загружается контекст нового потока
    Восстанавливаются его регистры, стек, указатель на текущую инструкцию.
    Процессор начинает выполнять этот поток.
    Процесс повторяется постоянно
    Это создаёт иллюзию, что несколько потоков работают параллельно даже на одном ядре (на самом деле ядро быстро переключается между ними).
    - Когда происходит переключение?
    Принудительно — ОС отбирает процессор у потока по тайм-кванту (например, каждые 10–15 мс).
    Добровольно — поток сам уступает управление (например, вызвал sleep(), wait(), join()).
    При блокировке — поток ждёт ввода-вывода или освобождения монитора (synchronized).
    - Цена переключения контекста
    Переключение — это дорогая операция:
    нужно сохранить текущий контекст,
    загрузить новый,
    обновить кеши процессора.
    Поэтому слишком много потоков может привести к "thrashing" — CPU тратит больше времени на переключения, чем на выполнение полезной работы.
	- ЗАЧАСТУЮ в обычных прогах не имеет смысла делать больше потоков чем ядер в процессоре.
12. Что произойдет, если run() вызван напрямую?
   - действия будут выполнены в рамках текущего потока
13. Как определить, завершился ли поток?
```java
        public static void main(String[] args) {
            Thread thread = new Thread("мой поток", () -> {
            System.out.println("опа");});
            thread.isAlive();
            Thread.currentThread().getState();
        }
```
14. Почему не рекомендуется обращаться к результату run() напрямую?
   - Получим просто вызов метода, а не отдельный поток.
     Весь смысл многопоточности теряется.
15. Как можно продемонстрировать текущее состояние потока?
```java
        public static void main(String[] args) {
            Thread thread = new Thread("мой поток", () -> {
            System.out.println("опа");});
            System.out.println(thread.isAlive());
            System.out.println(thread.getState());
        }
```
### Управление потоками:
16. Каковы основные отличия между wait(), notify(), и notifyAll()?
   - `wait()` - ставит поток в ожидание
   - `notify()` - будит рандомный поток от ожидания
   - `notifyAll()`- будит все потоки от ожидания
   - технически всегда можно использовать `notifyAll()`, однако это скажется на производительности
   - почему не всегда `notifyAll()` - ситуация когда может потребоваться проснуться нескольким потокам, например - состояние
    объекта после работы с ним подходит только одному заблокированному потоку из 3ех и чтобы не случился deadlock мы
    пробуждаем все потоки
17. Почему wait(), notify(), и notifyAll() должны вызываться внутри synchronized блока?
   - Потому что методы работают с монитором объекта, на котором вызываются, без этого как будто не будет корректно
   работать синхронизация, будет `java.lang.IllegalMonitorStateException`
18. Что происходит, когда notify() вызывается перед тем, как поток войдет в состояние ожидания?
   - ничего не произойдет если в очереди нет ожидающих
19. Как interrupt() влияет на sleep() поток?
   - выбрасывает `InterruptedException` при любом порядке вызова`interrupt() <-> sleep()`
20. Можно ли использовать stop() для прерывания потока и какие последствия это может иметь?
   - в старых JDK наверное можно - в новых
   Exception in thread "main" java.lang.UnsupportedOperationException
   at java.base/java.lang.Thread.stop(Thread.java:1705)
   at ru.belov.education.task_6_to_10.TaskTen.main(TaskTen.java:36)
   ПРИ ЭТОМ ПОТОК ПРОДОЛЖИЛ СВОЕ ВЫПОЛНЕНИЕ
21. Как правильно прервать выполнение потока?
```java
public static void main(String[] args) {
    while (!Thread.currentThread().isInterrupted()) {
        // работа
    }
}
```
22. Как обработать InterruptedException?
```java
public class InterruptedLoopDemo {
    public static void main(String[] args) throws InterruptedException {
        Thread worker = new Thread(() -> {
            while (true) {
                try {
                    System.out.println("Работаю...");
                    Thread.sleep(500); // можно словить InterruptedException
                } catch (InterruptedException e) {
                    System.out.println("Поймал InterruptedException");

                    // Восстанавливаем флаг (т.к. sleep его сбросил)
                    Thread.currentThread().interrupt();

                    // Игнорируем сигнал прерывания и продолжаем цикл
                    System.out.println("Флаг восстановлен, но продолжаю работать дальше");
                }
            }
        });

        worker.start();

        Thread.sleep(1500);    // дать поработать
        worker.interrupt();    // прерываем первый раз

        Thread.sleep(1500);
        worker.interrupt();    // прерываем второй раз

        Thread.sleep(1500);
        System.out.println("main завершён");
    }
}
```
23. Что такое "спонтанное пробуждение" и как его избежать?
**ПЛОХО**
```java
public static void main(String[] args) {
    synchronized (lock) {
        if (!condition) {
            lock.wait();
        }
        // здесь предполагается, что condition == true
        doWork();
    }
}
```
**ХОРОШО**
```java
public static void main(String[] args) {
    synchronized (lock) {
        while (!condition) {
            lock.wait();
        }
        doWork();
    }
}
```
24. Как interrupt() взаимодействует с операциями блокировки?
    - плохо, выдает `InterruptedException`
### Состояния потоков:

25. Перечислите основные состояния потока в Java.
- `NEW` - поток создан, но еще не запущен
- `RUNNABLE` - запущен, готов к выполнению или уже выполняется, ему ничего не мешает
- `WAITING` - спит, в ожидании пока его кто-то разбудит, можно получить как `thread.wait()` или `thread.join()`,
тогда блокируется тот поток, внутри которого был вызван этот метод и он будет ожидать завершения **thread**
- `TIMED_WAITING` - спит определенное время
  - `thread.wait(timeout)` - ждет пока его кто-то разбудит, может проснуться раньше таймаута (spurious wakeup). 
  Если при пробуждении потока (случайном или по истечению времени) поток проснется, а монитор все еще не свободен,
  то поток перейдет в состояние `BLOCKED`. При этом цикл wait никак не ориентирован и не предназначен для отслеживания
  состояния объекта поэтому для этого используют цикл while
  ```java 
  public static void main(String[] args){
    synchronized(lock) {
      while (!condition) {
          lock.wait(1000);
      }
    }
  }
    ```
  - `thread.join(timeout)` - ждет выполнения **thread**, может проснуться раньше таймаута, поэтому цикл while также _**recommended practice**_
  ```java
  public static void main(String[] args){
    long end = System.currentTimeMillis() + timeout;
    while (thread.isAlive() && System.currentTimeMillis() < end) {
        thread.join(end - System.currentTimeMillis());
    }
  }
    ```
  - `Thread.sleep(ms)`- спит определенное время
- `BLOCKED` - поток хочет войти в _synchronized-блок/метод_, но другой поток уже держит монитор.
- `TERMINATED` - поток завершил работу, его нельзя заново запустить, выдаст `IllegalThreadStateException`
26. Каковы условия перехода из одного состояния потока в другое?
- описаны выше
27. Что может привести поток в состояние BLOCKED?
- поток хочет войти в _synchronized-блок/метод_ какого-то объекта, но другой поток уже держит монитор.
28. Какой метод используется для перевода потока из состояния TIMED_WAITING в RUNNABLE?
- `thread.wait(timeout)` - ждет пока его кто-то разбудит, может проснуться раньше таймаута
- `thread.join(timeout)` - ждет выполнения **thread**, может проснуться раньше таймаута
- `Thread.sleep(ms)`- спит определенное время
29. Что означает состояние TERMINATED?
- поток завершил работу, его нельзя заново запустить, выдаст `IllegalThreadStateException`
### Приоритеты потоков:
30. Как задать приоритет потока в Java?
- `thread.setPriority(int (1-10))`
31. Как приоритеты потоков могут повлиять на их выполнение?
- при конкуренции, когда число потоков > числа ядер ОС определяет, какой поток ей следует запустить, приоритет является
рекомендацией для этого. По факту насколько я видел когда запускал несколько десятков потоков, разница не кратна,
 ~10 процентов на macOs
32. Есть ли гарантии выполнения высокоприоритетных потоков раньше низкоприоритетных?
- нет, гарантии нет
33. Что произойдет, если всем потокам установить максимальный приоритет?
- Все потоки окажутся в одинаковом положении для планировщика ОС.

### Проблемы многопоточности:

34. Что такое deadlock и как его можно избежать?
- Поток T1 захватил lock1 и ждёт lock2. 
- Поток T2 захватил lock2 и ждёт lock1. 
- Оба потока зависли → тупик.
- Фиксированный порядок захвата ресурсов, чтобы избежать его
```java
public static void main(String[] args) {
    synchronized (lock1) {
        synchronized (lock2) {
        }
    }
}
``` 
35. Приведите пример ситуации, приводящей к состоянию гонки (Race Condition)?
- два потока меняют состояние примитива увеличивая/уменьшая/меняя его или например добавление элемента в коллекцию
36. Каково правильное использование synchronized для избежания состояний гонки?
- Всё, что может быть одновременно изменено разными потоками (например, size, массивы, коллекции, счётчики), 
- должно защищаться доступами через synchronized методы или блоки.
37. Как volatile помогает в многопоточности?
- в Java переменные могут кэшироваться, а volatile гарантирует что чтение и запись будут происходить напрямую
из памяти, а не кэша. Не гарантирует атомарность действий по типу инкремента, декремента и в общем любой операции,
где требуется получить переменную, что-то с ней сделать и записать обратно в память
38. В каких ситуациях модификатор volatile полезен?
- Подходит **только** для флагов, состояний и одношаговых операций чтения/записи, например `obj.counter = 5`
39. Могут ли synchronized и volatile использоваться совместно, и если да, то как?
```java
class Singleton {
    private static volatile Singleton instance;

    private Singleton() {
    }

    public static Singleton getInstance() {
        if (instance == null) { // 1. первый "быстрый" чек без блокировки
            synchronized (Singleton.class) {
                if (instance == null) { // 2. второй чек внутри синхронизации
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```
- `synchronized` в данном случае защищает от одновременной инициализации объекта двумя потоками
  - Без `synchronized`:
    - два потока одновременно пройдут первый if (instance == null)
    - оба создадут новый Singleton
    - будут две разные инстанции
- первая проверка, чтобы лишний раз не входить в synchronized блок 
- А synchronized → это:
  - блокировка монитора,
  - системный вызов в ОС (дорогая операция, хоть и оптимизированная в современных JVM).
  - Если getInstance() вызывается часто (например, миллионы раз в секунду в серверном приложении), это становится ощутимой потерей производительности. 
#### Что такое happens-before
- `Happens-before` — это правило в Java Memory Model (JMM), которое гарантирует
- Если A happens-before B, то:
- Все операции записи, выполненные до A, будут видны операции B. 
- Операции не будут переставлены так, чтобы B произошло раньше A.
- A — это событие, которое выполняется в одном потоке, и которое создает гарантию видимости. 
  - Примеры события A:
    - запись volatile переменной (instance = obj;)
    - выход из блока synchronized (monitor exit)
    - вызов notify()
    - завершение конструктора объекта, который безопасно публикуется
- B — это событие в другом потоке, которое наблюдает изменения, сделанные до A. 
  - Примеры события B:
    - чтение той же volatile переменной (if (instance != null))
    - вход в блок synchronized (monitor enter)
    - вызов wait() после notify
- A — это instance = new Singleton() (volatile write)
- B — это if (instance != null) в другом потоке (volatile read)
- Гарантия: поток B увидит все изменения, которые произошли до записи volatile (например, x = 42), и объект будет полностью сконструирован.
- Проблема в том, что без happens-before между:
- `instance = new Singleton();` и `return instance;` потоки могут увидеть частично сконструированный объект.
- Почему?
- Потому что new Singleton() — это не атомарная операция.
- На первый взгляд всё безопасно. Но в JVM без volatile или synchronized возможен reorder:
  процессор и компилятор могут переставить шаги 2 и 3 для оптимизации:
    1. выделить память
    3. присвоить ссылку instance = obj
    2. выполнить конструктор
- Результат: другой поток видит instance != null, но объект ещё не полностью инициализирован.
- `volatile` запрещает переупорядочивание записи ссылки и инициализации.
40. Каковы основные симптомы deadlock?
- Программа "подвисла"
- Потоки перестают выполняться.
- Потоки находятся в состоянии BLOCKED или WAITING бесконечно
- В jstack / дебаггере видно, что несколько потоков заблокированы на synchronized или Lock.lock().
41. Что можно сделать для диагностики deadlock в многопоточном приложении?

_Jstack_ - часть jdk которая помогает анализировать потоки и их состояние
```
ps -ef | grep java
jstack <pid (procces ID)> > thread_dump.log
```
42. Почему использование volatile не всегда решает проблемы синхронизации?
- потому делает атомарными только операции _чтения/записи_, по сути чтоб переменные не кэшировались
43. Каковы последствия некорректной синхронизации переменных?
- _DEAD LOCK_
- _RACE CONDITION_
- _STARVATION (голодание)_ - это ситуация, когда поток теоретически может выполняться, но на практике он никогда 
не получает доступ к CPU или к нужному ресурсу, потому что его всё время "обгоняют" другие потоки.
- _LIVELOCK_ (живой тупик) - Потоки не заблокированы, но вечно реагируют друг на друга, не продвигаясь вперёд.
- _Memory visibility issues (проблемы видимости памяти)_ - 
  Один поток обновил значение переменной, но другой поток его не видит (читает старое значение из кеша).
    - Также как пример в игре эволюции, где поток может работать с уже ужаленным объектом

### Синхронизация:

44. Что происходит, если одна нить пытается получить доступ к synchronized методу другого объекта?
- Если монитор свободен → поток его захватывает и заходит в метод.
- Если монитор занят другим потоком → поток переходит в состояние BLOCKED и ждёт, пока монитор освободится.
45. Каковы преимущества использования блока synchronized вместо метода?
- сужение области блокировки, что позволяет ускорить выполнение программы 
46. Как правильно использовать блокировку на уровне класса?
- synchronized static метод
```java
class Example {
    public static synchronized void doSomething() {
        // доступ одновременно только у одного потока во всём приложении
    }
}
```
- synchronized блок на классе
```java
class Example {
    public void doSomething() {
        synchronized (Example.class) {
            // критическая секция, доступна только одному потоку на весь класс
        }
    }
    
}
```
47. Почему важно минимизировать размер synchronized блока?
- это позволит ускорить выполнение программы, некритические части кода будут выполняться параллельно
48. Приведите пример, демонстрирующий использование synchronized для достижения взаимного исключения.
```java
class Counter {
    private int count = 0;
    public synchronized void increment() {
        count++;
    }
    public synchronized int get() {
        return count;
    }
}

```
49. Можно ли синхронизировать статические методы и как это влияет на блокировку?
- Да. Блокировка идёт на объект Class (ClassName.class), общий для всех экземпляров.
50. Как использовать synchronized для обеспечения безопасности данных в многопоточном доступе?
- оборачивать чтение/запись/изменение общих полей в synchronized методы или блоки.
- Это гарантирует атомарность и видимость изменений между потоками.
- synchronized не только блокирует монитор, но и:
  - При входе в блок/метод:поток сбрасывает кэш **потока**, читает актуальные значения переменных из главной памяти.
  - При выходе: все изменения переменных записываются обратно в главную память,
    делаются видимыми для других потоков.